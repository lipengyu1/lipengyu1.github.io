(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{715:function(r,i,t){r.exports=t.p+"assets/img/StringBuilder.e8582962.png"},906:function(r,i,t){"use strict";t.r(i);var n=t(13),e=Object(n.a)({},(function(){var r=this,i=r.$createElement,n=r._self._c||i;return n("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[n("ol",[n("li",[r._v("一个可变的字符序列。此类提供个与StringBuffer兼容的API,但不保证同步。（StringBuilder不是线程安全）\n该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。\n如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快")]),r._v(" "),n("li",[r._v("在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。"),n("br"),r._v(" "),n("img",{attrs:{src:t(715),alt:"StringBuilder.png"}})])]),r._v(" "),n("h3",{attrs:{id:"stringbuilder常用方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#stringbuilder常用方法"}},[r._v("#")]),r._v(" StringBuilder常用方法")]),r._v(" "),n("p",[r._v("StringBuilder和StringBuffer均代表可变字符序列，方法是一样的，所以使用和StringBuffer一样"),n("br")]),r._v(" "),n("ol",[n("li",[r._v("StringBuilder继承AbstractStringBuilder")]),r._v(" "),n("li",[r._v("也实现的Serializable接口，StringBuilder可以串行化（可以网络传输，也可保存到文件）")]),r._v(" "),n("li",[r._v("StringBuilder 是final类，不能被继承")]),r._v(" "),n("li",[r._v("StringBuilder对象字符序列仍然存放在其父类AbstractStringBuilder的char[]  value"),n("br"),r._v("\n因此，存放在堆中"),n("br")]),r._v(" "),n("li",[r._v("StringBuilder的方法中，没有做互斥的处理，即没有synchronized关键字，因此在单线程的情况下使用StringBuilder")])]),r._v(" "),n("h3",{attrs:{id:"string、stringbuilder、stringbuffer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#string、stringbuilder、stringbuffer"}},[r._v("#")]),r._v(" String、StringBuilder、StringBuffer")]),r._v(" "),n("ol",[n("li",[r._v("StringBuffer与StringBuilder类似，均代表可变字符序列，而且方法也一样。")]),r._v(" "),n("li",[r._v("String：不可变字符序列，效率低，复用率高")]),r._v(" "),n("li",[r._v("StringBuffer：可变字符序列，效率较高（增删），线程安全")]),r._v(" "),n("li",[r._v("StringBuilder：可变字符序列，效率最高，线程不安全"),n("br"),r._v("\n效率 ：StringBuilder>StringBuffer>String")])])])}),[],!1,null,null,null);i.default=e.exports}}]);
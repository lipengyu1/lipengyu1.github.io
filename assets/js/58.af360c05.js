(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{868:function(a,t,_){"use strict";_.r(t);var v=_(13),r=Object(v.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h2",{attrs:{id:"java基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java基础"}},[a._v("#")]),a._v(" Java基础")]),a._v(" "),_("h3",{attrs:{id:"_1-面向对象的概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-面向对象的概念"}},[a._v("#")]),a._v(" "),_("em",[a._v("1.面向对象的概念")])]),a._v(" "),_("p",[a._v("相比于面向过程，是两种不同的处理问题的角度。")]),a._v(" "),_("p",[a._v("面向过程更注重于处理问题的步骤与顺序，面向对象更注重有哪些参与者，以及各自的作用。")]),a._v(" "),_("p",[a._v("面向过程会将业务分为几个步骤，而面向对象会拆接出几个对象，并分析每个对象的作用，因此面向对象更易于维护与扩展。")]),a._v(" "),_("p",[a._v("面向对象的三大特性、封装、继承、多态。")]),a._v(" "),_("p",[a._v("封装，私有化属性后，提供get、set访问方式。外部调用无需修改或关心内部实现。")]),a._v(" "),_("p",[a._v("继承，子类继承基类的方法，并作出自己特有的方法或扩展。")]),a._v(" "),_("p",[a._v("多态，建立在封装和继承基础之上，提高了代码的复用性，前提是继承关系，分为上转型和下转型，上转型是父类的引用指向了子类的对象，不能调用子类特有的成员，下转型强转父类的引用，可以调用子类的所有成员。")]),a._v(" "),_("h3",{attrs:{id:"_2-jdk、jre、jvm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-jdk、jre、jvm"}},[a._v("#")]),a._v(" "),_("em",[a._v("2.jdk、jre、jvm")])]),a._v(" "),_("p",[a._v("jdk，java development kit 开发工具")]),a._v(" "),_("p",[a._v("jre，java runtime environment java运行环境，用户运行java程序时需安装。")]),a._v(" "),_("p",[a._v("jvm，虚拟机，解释class文件，解释为机器码后让系统执行")]),a._v(" "),_("h3",{attrs:{id:"_3-与equals"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-与equals"}},[a._v("#")]),a._v(" "),_("em",[a._v("3.==与equals")])]),a._v(" "),_("p",[a._v("==可用来比较基本数据类型与引用数据类型，比较基本数据类型比较的是内容是否相等，比较引用类型是比较地址是否相等。")]),a._v(" "),_("p",[a._v("Equals 是Object中的方法，默认比较引用类型的地址是否相等，我们一般在子类重写equals方法，比较其内容是否相等。如果不重写，则与==等价。")]),a._v(" "),_("p",[a._v("重写equals时，我们也会重写hashcode，如果两个引用指向同一个对象，则他们的hash值相同，如果不是同一个对象，则哈希值也不同。重写hashcode就是为也保证对象通过重写equals方法进行比较时，保证hashcode对应。")]),a._v(" "),_("h3",{attrs:{id:"_4-final"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-final"}},[a._v("#")]),a._v(" "),_("em",[a._v("4.final")])]),a._v(" "),_("p",[a._v("final可以修饰类，此时该类不可被继承。")]),a._v(" "),_("p",[a._v("final可以修饰方法，此时该方法不可被覆盖/重写，但是可以重载。")]),a._v(" "),_("p",[a._v("final修饰变量，该变量一旦被赋值，就不可以修改")]),a._v(" "),_("p",[a._v("修饰局部变量：系统不会为局部变量进行初始化，需要程序员进行初始化，因此使用final修饰成员变量，可以在定义时赋值，也可以在之后的程序中赋值，但是只允许赋值一次。")]),a._v(" "),_("p",[a._v("修饰全局变量：静态变量，可以在静态代码块中、或声明时赋值。")]),a._v(" "),_("p",[a._v("普通成员变量：代码块中、构造器中、声明时赋值。")]),a._v(" "),_("h3",{attrs:{id:"_5-string、stringbuilder、stringbuffer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-string、stringbuilder、stringbuffer"}},[a._v("#")]),a._v(" "),_("em",[a._v("5.String、Stringbuilder、Stringbuffer")])]),a._v(" "),_("p",[a._v("String 自身是不可变对象， 每次对 String 类型进行操作都等同于产生了一个新的 String 对象，然后指向新的 String 对象。所以尽量不要对 String 进行大量的拼接操作，否则会产生很多临时对象，导致 GC 影响系统性能。")]),a._v(" "),_("p",[a._v("rStringbuffer都是在原来的对象上操作的")]),a._v(" "),_("p",[a._v("Stringbuffer是线程安全的，其中的方法都由synchronized修饰")]),a._v(" "),_("p",[a._v("Stringbuilder的效率最高。")]),a._v(" "),_("p",[a._v("在使用时，我们优先使用Stringbuilder，在多线程情况下，则会使用Stringbuffer保证数据安全。")]),a._v(" "),_("h3",{attrs:{id:"string-是final类型的原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#string-是final类型的原因"}},[a._v("#")]),a._v(" "),_("em",[a._v("String 是final类型的原因")])]),a._v(" "),_("p",[_("strong",[a._v("1、安全")]),a._v("\n在"),_("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[a._v("多线程"),_("OutboundLink")],1),a._v("的场景下，多个线程对String进行"),_("strong",[a._v("读")]),a._v("操作时，不会发生"),_("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[a._v("线程安全"),_("OutboundLink")],1),a._v("问题，而String是final类型的，具有不可变性，所以不能对String进行写操作，此时线程也是安全的。")]),a._v(" "),_("p",[_("strong",[a._v("2、实现字符串常量池")])]),a._v(" "),_("p",[a._v("​    当String是final类型时，才能实现字符串常量池。如果String不是final类型，当两个引用同时指向一个字符串对象时，其中一个引用修改字符串值时，另一个引用也会被修改。")]),a._v(" "),_("h3",{attrs:{id:"_6-说说-string-的-intern-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-说说-string-的-intern-方法"}},[a._v("#")]),a._v(" "),_("em",[a._v("6. 说说 String 的 intern() 方法？")])]),a._v(" "),_("p",[a._v("Stirng 中的 "),_("code",[a._v("intern()")]),a._v(" 是个 Native 方法，它会首先从常量池中查找是否存在该常量值的字符串，若不存在则先在常量池中创建，否则直接返回常量池已经存在的字符串的引用。")]),a._v(" "),_("h3",{attrs:{id:"重写与重载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重写与重载"}},[a._v("#")]),a._v(" "),_("em",[a._v("重写与重载")])]),a._v(" "),_("p",[a._v("重写基于父子类的，父类重写子类的方法，方法名相同，并且保证参数相同，及参数个数相同，参数类型相同，返回值类型小于等于父类，访问修饰符大于等于父类。")]),a._v(" "),_("p",[a._v("重载发生在同一个类当中，方法名相同，参数个数与类型不同，且返回值也可以不同，访问修饰符可以不同。")]),a._v(" "),_("h3",{attrs:{id:"_7-接口与抽象类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-接口与抽象类"}},[a._v("#")]),a._v(" "),_("em",[a._v("7.接口与抽象类")])]),a._v(" "),_("p",[a._v("抽象类：被 abstract 修饰的类就是抽象类，用来捕捉子类的通用性。它不能被实例化，只能用作子类的超类，抽象类是被用来创建继承层级里子类的模板。\n接口：可以说是一种特殊抽象类，接口中的所有方法都必须是抽象的。接口中的方法定义默认被 public abstract 修饰，接口中的成员变量类型默认 public static final。\n二者具体区别：")]),a._v(" "),_("p",[a._v("1）抽象类可以有非抽象方法，接口不存在非抽象方法；")]),a._v(" "),_("p",[a._v("2）使用 extends 继承抽象类并实现抽象方法，是 implements 实现接口中所有方法；")]),a._v(" "),_("p",[a._v("3）抽象类支持构造函数（但不能被 abstract 修饰），接口无构造函数；")]),a._v(" "),_("p",[a._v("4）抽象类的抽象方法可以被 public、protected、default 修饰，接口只能是 public；")]),a._v(" "),_("p",[a._v("5）接口的设计目的是为了约束，要求某个实现类要有具体的某个行为。但是他只约束是否有这个方法，不对其如何实现做限制。")]),a._v(" "),_("h3",{attrs:{id:"java-有哪四种引用类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java-有哪四种引用类型"}},[a._v("#")]),a._v(" "),_("em",[a._v("Java 有哪四种引用类型？")])]),a._v(" "),_("p",[a._v("强引用（Strong Reference）\n是 Java 中默认声明的引用类型，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时， JVM 也会直接抛出 OutOfMemoryError 而不会去回收。")]),a._v(" "),_("p",[a._v("软引用（Soft Reference）\n软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。 这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。")]),a._v(" "),_("p",[a._v("弱引用（Weak Reference）\n弱引用的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。 使用 java.lang.ref.WeakReference 来表示弱引用。")]),a._v(" "),_("p",[a._v("虚引用（Phantom Reference）\n虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。这个类 只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。")]),a._v(" "),_("h3",{attrs:{id:"_12-java的类加载器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-java的类加载器"}},[a._v("#")]),a._v(" "),_("em",[a._v("12.java的类加载器")])]),a._v(" "),_("p",[a._v("java类加载器有bootstrap classloader，extclassoder，appclassloder")]),a._v(" "),_("p",[a._v("bootstrap classloader是extclassoder的父类加载器，默认加载Javahome下lib文件夹中的class文件与jar包。")]),a._v(" "),_("p",[a._v("extclassoder是appclassloder的父类加载器，默认加载Javahome下lib文件夹下ext文件夹中的class文件与jar包。")]),a._v(" "),_("p",[a._v("appclassloder是自定义类加载器的父类，加载classpath下的类文件。")]),a._v(" "),_("p",[a._v("可以通过继承appclassloder实现自定义类加载器。")]),a._v(" "),_("h3",{attrs:{id:"_13-双亲委派模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-双亲委派模型"}},[a._v("#")]),a._v(" "),_("em",[a._v("13.双亲委派模型")])]),a._v(" "),_("p",[a._v("双亲委派模型，其实就是一种类加载器的层次关系。")]),a._v(" "),_("p",[a._v("首先从底向上的检查类是否已经加载过，实质是查找缓存，有则直接返回，没有继续向上。加载到顶层后，如果还是没有，就会到加载路径中查找，有则返回，没有就继续向下查找。")]),a._v(" "),_("p",[a._v("其好处是：提高了安全性，避免用户自己编写的类动态替换java中的核心类，同时避免了类的重复加载。比如相同的class文件被不同的classloder加载就是不同的两个类。")]),a._v(" "),_("h3",{attrs:{id:"_14-异常体系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-异常体系"}},[a._v("#")]),a._v(" "),_("em",[a._v("14.异常体系")]),a._v("*")]),a._v(" "),_("p",[a._v("常分为两大类，运行时异常和编译时异常\n运行时异常，编译器检查不出来。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。")]),a._v(" "),_("h3",{attrs:{id:"_15-throws与throw"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_15-throws与throw"}},[a._v("#")]),a._v(" "),_("em",[a._v("15.throws与throw")])]),a._v(" "),_("p",[a._v("throw 用于程序员自行产生并抛出异常, throws 用于声明该方法内抛出了异常，throw 位于方法体内部,可以作为单独语句使用; throws 必须跟在方法参数列表的后面,不能单独使用。throw 抛出一个异常对象,且只能是一个; throws 后面跟异常类,且可以跟多个异常类。")]),a._v(" "),_("p",[a._v("throws 抛出的异常一般交给调用者进行处理。")]),a._v(" "),_("h3",{attrs:{id:"_5、类初始化顺序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5、类初始化顺序"}},[a._v("#")]),a._v(" "),_("em",[a._v("5、类初始化顺序？")])]),a._v(" "),_("p",[a._v("1）父类–静态变量/静态初始化块（按代码顺序）；")]),a._v(" "),_("p",[a._v("2）子类–静态变量/静态初始化块；")]),a._v(" "),_("p",[a._v("3）父类–变量/初始化块；")]),a._v(" "),_("p",[a._v("4）父类–构造器；")]),a._v(" "),_("p",[a._v("5）子类–变量/初始化块；")]),a._v(" "),_("p",[a._v("6）子类–构造器。")]),a._v(" "),_("h3",{attrs:{id:"浅拷贝与深拷贝的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝与深拷贝的区别"}},[a._v("#")]),a._v(" 浅拷贝与深拷贝的区别")]),a._v(" "),_("h3",{attrs:{id:"_19-java类加载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_19-java类加载"}},[a._v("#")]),a._v(" 19.java类加载")]),a._v(" "),_("p",[a._v("类加载分为静态加载和动态加载")]),a._v(" "),_("p",[a._v("静态加载：通过new关键字来实例化对象")]),a._v(" "),_("p",[a._v("动态加载：通过Class.forName()来加载类，调用newInstance()方法实例化对象")]),a._v(" "),_("p",[a._v("类加载器：通过类加载器的loadClass()方法来加载类，然后调用类的newInstance()方法实例化对象")]),a._v(" "),_("h3",{attrs:{id:"_20-java反射-class-forname-加载类和使用classloader加载类的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_20-java反射-class-forname-加载类和使用classloader加载类的区别"}},[a._v("#")]),a._v(" 20. java反射 class.forName()加载类和使用classLoader加载类的区别")]),a._v(" "),_("p",[a._v("（Class.forName加载类是将类进行了初始化，而ClassLoader的loadClass并没有对类进行初始化，只是把类加载到了虚拟机中。）")]),a._v(" "),_("p",[a._v("在java中Class.forName()和ClassLoader都可以对类进行加载。ClassLoader就是遵循双亲委派模型最终调用启动类加载器的类加载器。")]),a._v(" "),_("h2",{attrs:{id:"java集合"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java集合"}},[a._v("#")]),a._v(" Java集合")]),a._v(" "),_("h3",{attrs:{id:"_3、数组和集合的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、数组和集合的区别"}},[a._v("#")]),a._v(" "),_("em",[a._v("3、数组和集合的区别？")])]),a._v(" "),_("p",[a._v("数组固定长度，集合成都可变；")]),a._v(" "),_("p",[a._v("数组可以存放基本数据类型，集合只能存储引用数据类型；")]),a._v(" "),_("p",[a._v("数组存储的元素必须是同一个数据类型，集合支持存储不同数据类型。")]),a._v(" "),_("h3",{attrs:{id:"_4、集合是否可以存储-null"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、集合是否可以存储-null"}},[a._v("#")]),a._v(" "),_("em",[a._v("4、集合是否可以存储 NULL？")])]),a._v(" "),_("p",[a._v("1）AList 接口 ArrayList、LinkedList 以及 Vector 等都可以存储多个 null；")]),a._v(" "),_("p",[a._v("2）Set 接口中 HashSet、LinkedSet 可以存储一个 null，TreeSet 不能存储 null；")]),a._v(" "),_("p",[a._v("3）Map 接口中 HashMap、LinkedHashMap 的 key 与 value 均可以为 null。Treemap 的 key 不可以为 null，value 可以为 null。HashTable、ConcurrentHashMap 的 key 与 value 均不能为 null。")]),a._v(" "),_("h3",{attrs:{id:"_8-list-、set"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-list-、set"}},[a._v("#")]),a._v(" "),_("em",[a._v("8.list 、set")])]),a._v(" "),_("p",[a._v("list集合是有序，且可重复，其按照进入的顺序保存对象，并且允许有多个null元素。可以只用迭代器进行遍历，取出所有元素，也可以通过index获取指定下标的元素。")]),a._v(" "),_("p",[a._v("set集合是无序，且不可重复。最多只允许一个null元素。获取元素时只允许迭代器获取元素。")]),a._v(" "),_("p",[a._v("迭代器原理：")]),a._v(" "),_("p",[a._v("得到迭代器后，通过hashnext（）方法判断是否还有下一个元素，next（）指针下移，将集合位置上的元素返回。")]),a._v(" "),_("h3",{attrs:{id:"_9-arraylist、linkedlist"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-arraylist、linkedlist"}},[a._v("#")]),a._v(" "),_("em",[a._v("9.ArrayList、LinkedList")])]),a._v(" "),_("p",[a._v("二者都是 List 接口的实现，顾名思义，从数据结构上看，它们底层一个是数组，一个是链表的数据结构。前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列。")]),a._v(" "),_("p",[a._v("1）访问效率的不同")]),a._v(" "),_("p",[a._v("对于随机访问（get 和 set）操作，ArrayList 效率比 LinkedList 更高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。\n对于数据增加删除（add 和 remove）操作，LinkedList 的效率又会比 ArrayList 更高，因为数组在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。\n2）利用效率的不同")]),a._v(" "),_("p",[a._v("从利用效率来看，ArrayList 自由性较低，因为它需要有手动或默认一个固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而 LinkedList 自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。")]),a._v(" "),_("p",[a._v("3）控件开销的不同")]),a._v(" "),_("p",[a._v("ArrayList 控件开销在于底层数组中预留了一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。")]),a._v(" "),_("h3",{attrs:{id:"_2、arraylist-和-vector-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、arraylist-和-vector-的区别"}},[a._v("#")]),a._v(" "),_("em",[a._v("2、ArrayList 和 Vector 的区别？")])]),a._v(" "),_("p",[a._v("同步性不同\nVector 是线程安全的，它的方法之间都加了 synchronized 关键字修饰，而 ArrayList 是非线程安全的。因此在不考虑线程安全情况下使用 ArrayList 的效率更高。")]),a._v(" "),_("p",[a._v("数据增长不同\nArrayList 和 Vector 都有一个初始的容量大小，并在必要时对数组进行扩容。但 Vector 每次增长两倍，而 ArrayList 增长 1.5 倍。")]),a._v(" "),_("h3",{attrs:{id:"_4、iterator-和-listiterator-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、iterator-和-listiterator-的区别"}},[a._v("#")]),a._v(" "),_("em",[a._v("4、Iterator 和 ListIterator 的区别？")])]),a._v(" "),_("p",[a._v("ListIterator 是一个继承于 Iterator 接口，功能更加强大的迭代器，但只能用于各种 List 类型的访问。")]),a._v(" "),_("p",[a._v("故二者的主要区别：")]),a._v(" "),_("p",[a._v("Iterator 支持 List 和 Set，而 ListIterator 只支持 List；\nIterator 只能单向访问，而 ListIterator 可以双向前后遍历；\nListIterator 继承了 Iterator 的所有方法，并新增了如添加 add()、替换 set() 等更多好用方法。")]),a._v(" "),_("h3",{attrs:{id:"_2、链表和红黑树之间的转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、链表和红黑树之间的转换"}},[a._v("#")]),a._v(" "),_("em",[a._v("2、链表和红黑树之间的转换？")])]),a._v(" "),_("ul",[_("li",[a._v("链表长度大于 8 且数组长度大于 64，则将链表转换成红黑树；")]),a._v(" "),_("li",[a._v("链表长度小于 6 时会将红黑树转换成链表。")])]),a._v(" "),_("h3",{attrs:{id:"hashmap与hashtable"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hashmap与hashtable"}},[a._v("#")]),a._v(" "),_("em",[a._v("HashMap与HashTable")])]),a._v(" "),_("p",[a._v("hashtable继承了dictionary类，而HashMap继承了abstractMap类。")]),a._v(" "),_("p",[a._v("HashMap的key和 value 允许为空，hashtable不允许。")]),a._v(" "),_("p",[a._v("hashtable中的所有方法都有synchronized修饰，实现了同步，而hashmap是线程不安全的。")]),a._v(" "),_("p",[a._v("HashMap的底层是数组、链表、红黑树 数组默认大小为16，加载因因子为0.75，当数组达到临界值时，进行二倍扩容，当链表元素个数达到8，数组长度达到64时，转为红黑树。")]),a._v(" "),_("p",[a._v("hashtable的数组默认大小的为11，扩容为2倍加1的扩容方式。")]),a._v(" "),_("p",[a._v("hashmap插入方式：计算key的hash值，二次hash后对数组长度取模，获得下标，在数组中判断是否重复，不重复则创建节点后存入，重复则equal比较，相同会进行覆盖，不同插入链表。")]),a._v(" "),_("h3",{attrs:{id:"_4、为何使用红黑树而非二叉树或平衡树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、为何使用红黑树而非二叉树或平衡树"}},[a._v("#")]),a._v(" "),_("em",[a._v("4、为何使用红黑树而非二叉树或平衡树？")])]),a._v(" "),_("p",[a._v("相比普通二叉树，红黑树是一棵平衡树，它的添加、删除和查找操作最差时间复杂度为 o(logn)，避免了普通二叉树最差情况下 o(n) 的复杂度。")]),a._v(" "),_("p",[a._v("平衡二叉树是比红黑树更加严格的平衡树，为了达到平衡需要进行更多的旋转次数，所以红黑树插入删除操作效率更高。")]),a._v(" "),_("h3",{attrs:{id:"_8、hashmap-容量为何是-2-的倍数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8、hashmap-容量为何是-2-的倍数"}},[a._v("#")]),a._v(" 8、HashMap 容量为何是 2 的倍数？")]),a._v(" "),_("p",[a._v("主要有两个原因：")]),a._v(" "),_("p",[a._v("1）为了方便哈希取余，因为当除数是 2 的倍数时，可以将 % 取模运算将换成 & 位运算，以达到更高的运算效率；")]),a._v(" "),_("p",[a._v("2）扩容后容量也是 2 的倍数，则每个桶中的节点要么保留在当前位置，要么移动 2 次幂的位置（即 原位置+原数组容量），这样就可以快速简洁的完成数据迁移。")]),a._v(" "),_("h3",{attrs:{id:"_11-ioc容器实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-ioc容器实现"}},[a._v("#")]),a._v(" "),_("em",[a._v("11.IOC容器实现")])]),a._v(" "),_("p",[a._v("设置配置文件指定要扫描的包路径，定义一些注解，如模型层、业务层、依赖注入等，从扫描的包路径获取路径下的文件的信息，将所有以。class结尾的文件放入set集合中。遍历set集合，获取有指定注解的类，将其放入ioc容器中（map），之后遍历ioc容器，获取到每一个类的实例，进行依赖注入等。")]),a._v(" "),_("h3",{attrs:{id:"_16-collections与collection"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_16-collections与collection"}},[a._v("#")]),a._v(" "),_("em",[a._v("16.collections与collection")])]),a._v(" "),_("p",[a._v("Collection 是一个 集合框架的父接口，有子接口List和Set。")]),a._v(" "),_("p",[a._v("collections是一个包装类，它包含有各种有关集合操作的 静态方法。此类 不能实例化，是一 个工具类。")]),a._v(" "),_("h3",{attrs:{id:"_17-concurrenthashmap"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_17-concurrenthashmap"}},[a._v("#")]),a._v(" 17.concurrentHashMap")]),a._v(" "),_("p",[a._v("ConcurrentHashMap是HashMap的升级版，HashMap是线程不安全的，而ConcurrentHashMap是线程安全。而其他功能和实现原理和HashMap类似。")]),a._v(" "),_("p",[a._v("ConcurrentHashMap只对put/remove同步。（Hashtable对get/put/remove都使用了同步操作）")]),a._v(" "),_("p",[a._v("JDK1.7 中，ConcurrentHashMap 由数组 + Segment + 分段锁实现，将map拆分成多个Segment，不同线程操作不同的Segment，互不影响，实现并发操作。")]),a._v(" "),_("p",[a._v("JDK1.8中，选择了与 HashMap 相同的"),_("strong",[a._v("Node数组+链表+红黑树")]),a._v("结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用"),_("code",[a._v("CAS + synchronized")]),a._v("实现。使用synchronized加锁，对链表头结点和红黑树根结点来加锁，")]),a._v(" "),_("h3",{attrs:{id:"_18-cas"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_18-cas"}},[a._v("#")]),a._v(" "),_("em",[a._v("18.CAS")])]),a._v(" "),_("p",[a._v("CAS（Compare And Swap 比较并且替换）是乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。")]),a._v(" "),_("p",[a._v("线程在读取数据时不进行加锁，在准备写回数据时，先去查询原值，操作的时候比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。")]),a._v(" "),_("h3",{attrs:{id:"_21-vector"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_21-vector"}},[a._v("#")]),a._v(" "),_("em",[a._v("21.vector")])]),a._v(" "),_("ol",[_("li",[a._v("Vector底层也是一个对象数组，protected Object[] elementData")]),a._v(" "),_("li",[a._v("Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized")]),a._v(" "),_("li",[a._v("在开发中，需要线程同步安全是，考虑使用Vector")])]),a._v(" "),_("h2",{attrs:{id:"mybatis"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mybatis"}},[a._v("#")]),a._v(" Mybatis")]),a._v(" "),_("h3",{attrs:{id:"_1-mybatis优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-mybatis优缺点"}},[a._v("#")]),a._v(" "),_("em",[a._v("1.mybatis优缺点")])]),a._v(" "),_("p",[a._v("基于sql语言，不会对程序和数据库造成影响，他的sql文件写在xml配置文件中或注解中。")]),a._v(" "),_("p",[a._v("降低了代码冗余，不需要手动链接和释放资源。")]),a._v(" "),_("p",[a._v("与各种数据库兼容。")]),a._v(" "),_("p",[a._v("提供对象关系映射标签。")]),a._v(" "),_("p",[a._v("缺点：sql语句编写工作量大，依赖数据库，移植性差。")]),a._v(" "),_("h3",{attrs:{id:"_2-与"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-与"}},[a._v("#")]),a._v(" 2.#{}与${}")]),a._v(" "),_("p",[a._v("#{}是预编译处理，是占位符，${}是字符串替换，是拼接符。")]),a._v(" "),_("p",[a._v("#{}会将sql中的#{}替换为？号，调用preparestatement来赋值，可以防止sql注入。")]),a._v(" "),_("p",[a._v("${}会将sql中的${}替换成变量的值，调用statement来赋值。")]),a._v(" "),_("p",[a._v("同时，#{}的变量替换是在DBMS中、变量替换后，#{}对应的变量自动加上单引号，${}的变量替换是在DBMS外、变量替换后，${}对应的变量不会加上单引号")]),a._v(" "),_("h2",{attrs:{id:"spring"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[a._v("#")]),a._v(" Spring")]),a._v(" "),_("h3",{attrs:{id:"_1-spring是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-spring是什么"}},[a._v("#")]),a._v(" 1.spring是什么")]),a._v(" "),_("p",[a._v("开源的j2ee框架，是一个实现IOC和Aop的容器框架，用来装javabean，也是一个中间层框架，可以整合其他框架。")]),a._v(" "),_("h3",{attrs:{id:"_2-aop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-aop"}},[a._v("#")]),a._v(" 2.AOP")]),a._v(" "),_("p",[a._v("面向切面编程，是oop面向对象的补充，就是可以把不同类、不同方法中的重复的业务逻辑（日志、事务等）封装成一个切面，然后注入到对象中。")]),a._v(" "),_("h3",{attrs:{id:"_3-ioc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-ioc"}},[a._v("#")]),a._v(" 3.IOC")]),a._v(" "),_("p",[a._v("控制反转，在没有使用IOC之前我们需要自己取创建和管理对象，代码的耦合性比较高，在使用了IOC之后Bean对象的创建和管理都交给spring的IOC容器进行，降低了耦合度。")]),a._v(" "),_("h3",{attrs:{id:"_4-beanfactory与applicationcontext"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-beanfactory与applicationcontext"}},[a._v("#")]),a._v(" 4.beanfactory与applicationcontext")]),a._v(" "),_("p",[a._v("applicationcontext是beanfactory的子接口，applicationcontext提供了更完整的功能：")]),a._v(" "),_("p",[a._v("继承了messagesource，支持国际化")]),a._v(" "),_("p",[a._v("统一的资源文件访问方式")]),a._v(" "),_("p",[a._v("可同时加载多个配置文件等")]),a._v(" "),_("p",[a._v("beanfactory采用延迟加载的形式注入bean，也就是只有使用到某个bean时才会对该bean进行实例化。applicationcontext在容器启动时会实例化所有的bean。所以如果有较多的bean会导致启动速度慢。")]),a._v(" "),_("p",[a._v("BeanFactory通常以编程的方式创建，ApplicationCotext还能以声明的方式创建。")]),a._v(" "),_("p",[a._v("注册方式：\nBeanFactory,ApplicationCotext都支持BeanPostProcessor,BeanFactoryPostProcessor的使用，两者区别：BeanFactory需要手动注册，ApplicationContext是自动注册。")]),a._v(" "),_("h3",{attrs:{id:"_5-springbean生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-springbean生命周期"}},[a._v("#")]),a._v(" 5.springbean生命周期")]),a._v(" "),_("p",[a._v("1、解析类得到BeanDefinition\n2、如果有多个构造方法，则要推断构造方法\n3、确定好构造方法后，进行实例化得到一个对象\n4、对对象中的加了@Autowired注解的属性进行属性填充\n5、回调Aware方法，比如BeanNameAware，BeanFactoryAware\n6、调用BeanPostProcessor的初始化前的方法\n7、调用初始化方法\n8、调用BeanPostProcessor的初始化后的方法，在这里会进行AOP\n9、如果当前创建的bean是单例的则会把bean放入单例池\n10、使用bean\n11、Spring容器关闭时调用DisposableBean中destory()方法")]),a._v(" "),_("h3",{attrs:{id:"_6-bean的作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-bean的作用域"}},[a._v("#")]),a._v(" 6.bean的作用域")]),a._v(" "),_("ul",[_("li",[a._v("sin gleton：默认，每个容器中只有一个bean实例，由BeanFactory自身来维护，该对象的生命周期与ioc容器一致，在第一次被注入时才会创建")]),a._v(" "),_("li",[a._v("prototype：为每一个bean请求提供一个实例，在每次注入时都会创建一个新的对象")]),a._v(" "),_("li",[a._v("request：bean 被定义为在每一个http请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象")]),a._v(" "),_("li",[a._v("session：与request范围类型，确保每个session中有一个bean的实例，在session过期后，bean会随之失效")]),a._v(" "),_("li",[a._v("application：bean被定义为在servletContext的生命周期中复用一个单例对象")]),a._v(" "),_("li",[a._v("web soc ket：bean被定义为在websocket的生命周期中复用一个单例对象")])]),a._v(" "),_("p",[a._v("global-session：全局作用域，global-session 和 Portlet应用相关，当你的应用部署在Portlet容器中工作时，它包含很多Portlet，如果你想要声明让所有的Portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中，全局作用域与servlet中的session作用域效果相同")]),a._v(" "),_("h3",{attrs:{id:"_7-spring框架中的单例bean是线程安全的么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-spring框架中的单例bean是线程安全的么"}},[a._v("#")]),a._v(" 7.spring框架中的单例bean是线程安全的么")]),a._v(" "),_("p",[a._v("Spring容器本身并没有提供Bean的线程安全策略，容器中的Bean本身不具备线程安全的特性。")]),a._v(" "),_("p",[a._v("对于prototype作用域的Bean，每次都创建一个新对象，也就是线程之间不存在Bean共享，因此不会有线程安全问题。")]),a._v(" "),_("p",[a._v("对于singleton作用域的Bean，所有的线程都共享一个单例实例的Bean，因此是存在线程安全问题的。但是如果单例Bean是一个无状态（不会保存数据）Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Controller类、Service类和Dao等，这些Bean大多是无状态的，只关注于方法本身。")]),a._v(" "),_("p",[a._v("对于有状态（会保存数据）的bean（比如Model和View），就需要自行保证线程安全，可以将有状态的bean的作用域由“singleton”改为“prototype”。")]),a._v(" "),_("p",[a._v("————")]),a._v(" "),_("p",[a._v("可以采用ThreadLocal解决线程安全问题，为每个线程提供一个独立的变量副本，不同线程只操作自己线程的副本变量。")]),a._v(" "),_("h3",{attrs:{id:"_8-spring框架中用到了哪些设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-spring框架中用到了哪些设计模式"}},[a._v("#")]),a._v(" 8.spring框架中用到了哪些设计模式")]),a._v(" "),_("h3",{attrs:{id:"_9-spring事务的实现方式和原理以及隔离级别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-spring事务的实现方式和原理以及隔离级别"}},[a._v("#")]),a._v(" 9.spring事务的实现方式和原理以及隔离级别")]),a._v(" "),_("p",[a._v("编程式和申明式，@tran saction注解就是申明式。")]),a._v(" "),_("p",[a._v("事务的概念是数据库层面的，spring的事务是一个扩展。它在数据层或业务层保障一系列的数据库操作同时成功同时失败")]),a._v(" "),_("p",[a._v("在方法上通过@Transactional注解开启事务，这个方法里所有的sql都会在一个事务中进行。spring会生成一个代理对象，将"),_("strong",[a._v("代理对象作为bean")]),a._v("，当使用这个代理对象的方法时，如果存在Transactional注解，"),_("strong",[a._v("代理逻辑")]),a._v("就会把事务自动提交设置为FALSE，然后去执行业务逻辑，如果业务逻辑没有出现异常，代理逻辑中会提交事务，如果出现异常，就会进行事务回滚。")]),a._v(" "),_("p",[a._v("隔离级别：")]),a._v(" "),_("p",[a._v("默认隔离级别")]),a._v(" "),_("p",[a._v("read uncommitted（未提交读）允许读取尚未提交的数据变更")]),a._v(" "),_("p",[a._v("read committed （提交读，不可重复读）允许读取并发事务已经提交的数据")]),a._v(" "),_("p",[a._v("repeatable read （可重复读）对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改")]),a._v(" "),_("p",[a._v("serializable （可串行化）")]),a._v(" "),_("h3",{attrs:{id:"_10-spring事务的传播机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-spring事务的传播机制"}},[a._v("#")]),a._v(" 10.spring事务的传播机制")]),a._v(" "),_("h3",{attrs:{id:"_11-bean的装配方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-bean的装配方式"}},[a._v("#")]),a._v(" 11.bean的装配方式")]),a._v(" "),_("ol",[_("li",[a._v("xml文件中显式配置\nref=“bean的id”")]),a._v(" "),_("li",[a._v("通过注解装配 Bean\n类上加注解@Component\n扫描类@ComponentScan")]),a._v(" "),_("li",[a._v("自动装配——@Autowired")])]),a._v(" "),_("h3",{attrs:{id:"_12-spring、springboot、springmvc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-spring、springboot、springmvc"}},[a._v("#")]),a._v(" 12.spring、springboot、springmvc")]),a._v(" "),_("p",[a._v("spring是一个ioc容器，用来管理bean，使用依赖注入实现控制翻转，可以方便的整合其他框架，提供aop解决代码重复的问题，可以将不同类不同方法中的共同点抽取成切面，自动注入给方法去执行。(日志、异常)")]),a._v(" "),_("p",[a._v("SpringMVC是spring的一个模块，是实现了MVC设计模式的一个web框架。")]),a._v(" "),_("p",[a._v("springboot是spring提供的一个快速开发工具包，简化了spring的使用难度，遵循“约定优于配置”的原则，降低了对配置文件的要求。")]),a._v(" "),_("h3",{attrs:{id:"_13-springmvc工作流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-springmvc工作流程"}},[a._v("#")]),a._v(" 13.springmvc工作流程")]),a._v(" "),_("h3",{attrs:{id:"_14-springmvc九大组件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-springmvc九大组件"}},[a._v("#")]),a._v(" 14.springmvc九大组件")]),a._v(" "),_("h3",{attrs:{id:"_15-springboot自动配置原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_15-springboot自动配置原理"}},[a._v("#")]),a._v(" 15.springboot自动配置原理")]),a._v(" "),_("h3",{attrs:{id:"_16-springboot中的starter"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_16-springboot中的starter"}},[a._v("#")]),a._v(" 16.springboot中的starter")]),a._v(" "),_("h3",{attrs:{id:"_17-什么是嵌入式服务器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_17-什么是嵌入式服务器"}},[a._v("#")]),a._v(" 17.什么是嵌入式服务器")]),a._v(" "),_("p",[a._v("springboot内置了tomcat.jar,运行main方法就会启动tomcat，并利用tomcat的spi机制加载springmvc。")]),a._v(" "),_("p",[a._v("只需安装java虚拟机就可以部署应用程序，不许要下载服务器。")]),a._v(" "),_("h2",{attrs:{id:"mysql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[a._v("#")]),a._v(" Mysql")]),a._v(" "),_("h3",{attrs:{id:"_1-如果要存放金额等带精度的数据-使用什么字段类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-如果要存放金额等带精度的数据-使用什么字段类型"}},[a._v("#")]),a._v(" 1.如果要存放金额等带精度的数据，使用什么字段类型？")]),a._v(" "),_("p",[a._v("decimal  数字类型")]),a._v(" "),_("p",[a._v("Decimal(n,m)表示数值中共有n位数，其中整数n-m位，小数m位。例：decimal(10,6)，数值中共有10位数，其中整数占4位，小数占6位。")]),a._v(" "),_("h3",{attrs:{id:"_2-mysql存储引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-mysql存储引擎"}},[a._v("#")]),a._v(" 2. mysql存储引擎")]),a._v(" "),_("p",[a._v("myisam：不支持事务，每次查询都是原子的")]),a._v(" "),_("p",[a._v("支持表级锁，每次操作都是对整个表加锁")]),a._v(" "),_("p",[a._v("存储表的总行数")]),a._v(" "),_("p",[a._v("InnoDB：支持Acid事务")]),a._v(" "),_("p",[a._v("支持行级锁和外键约束")]),a._v(" "),_("p",[a._v("不存储注行数")]),a._v(" "),_("h3",{attrs:{id:"锁的类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#锁的类型"}},[a._v("#")]),a._v(" 锁的类型")]),a._v(" "),_("p",[a._v("基于锁的粒度分类有行级锁、表级锁、页级锁、记录锁、间隙锁、临键锁")]),a._v(" "),_("p",[a._v("基于属性分类的话有共享锁、排它锁")]),a._v(" "),_("p",[a._v("共享锁-读锁，加锁后其他事务只能对该数据加读锁，不能加写锁，读数据时不能修改。")]),a._v(" "),_("p",[a._v("排它锁-写锁，加锁后其他事务不能对该事务加任何锁。修改数据时不能被别人修改和读取。")]),a._v(" "),_("h3",{attrs:{id:"_3-事务隔离级别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-事务隔离级别"}},[a._v("#")]),a._v(" 3.事务隔离级别")]),a._v(" "),_("p",[a._v("事务隔离级别")]),a._v(" "),_("p",[a._v("RU\tread uncommitte 脏读，未提交读，读到了其他未提交的事务")]),a._v(" "),_("p",[a._v("RC\tread community 不可重复读，只会读取已提交的事务")]),a._v(" "),_("p",[a._v("RR\trepeatable read 可重复读，MySQL的的默认级别，每次读取的数据相同。会有幻读的问题。")]),a._v(" "),_("p",[a._v("serializable 串行")]),a._v(" "),_("h3",{attrs:{id:"_4-事务的基本特性acid及如何保证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-事务的基本特性acid及如何保证"}},[a._v("#")]),a._v(" 4.事务的基本特性ACID及如何保证")]),a._v(" "),_("ul",[_("li",[a._v("A原子性：一个事务的操作要么全成功，要么全失败")])]),a._v(" "),_("p",[a._v("undo log日志保证，"),_("strong",[a._v("记录了回滚日志信息")]),a._v("，回滚时撤销已经执行的sql")]),a._v(" "),_("ul",[_("li",[a._v("I隔离性：事务的修改在最终提交前是不可见的")])]),a._v(" "),_("p",[a._v("MVCC（多版本并发控制）保证")]),a._v(" "),_("ul",[_("li",[a._v("D持久性：事务一旦提交，就会永久保存")])]),a._v(" "),_("p",[a._v("redo log加内存保证，数据修改时在内存和redo log记录操作")]),a._v(" "),_("p",[a._v("C一致性：应用系统从一个正确的状态到另一个正确的状态，前三个特性保证了事务的一致性。")]),a._v(" "),_("h3",{attrs:{id:"_5-索引的基本原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-索引的基本原理"}},[a._v("#")]),a._v(" 5.索引的基本原理")]),a._v(" "),_("p",[a._v("索引用来快速寻找有特定值的记录。如果没有索引，执行查询时要遍历整张表")]),a._v(" "),_("p",[a._v("原理：把无需的数据变为有序的查询")]),a._v(" "),_("ol",[_("li",[a._v("把创建了索引的列的内容进行排序")]),a._v(" "),_("li",[a._v("对排序结果生成倒排表")]),a._v(" "),_("li",[a._v("在倒排表上拼接数据地址链")]),a._v(" "),_("li",[a._v("在查询时，先拿到倒排表的内容，在取出地址链的地址，就拿到了数据")])]),a._v(" "),_("h3",{attrs:{id:"_6-mysql索引类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-mysql索引类型"}},[a._v("#")]),a._v(" 6.Mysql索引类型")]),a._v(" "),_("p",[a._v("普通索引：允许被索引的数据列包含重复的值")]),a._v(" "),_("p",[a._v("唯一索引：保证数据的唯一性")]),a._v(" "),_("p",[a._v("主键：是一种特殊的唯一索引，一张表只能定义一个主键索引，主键用于唯一标识一条记录")]),a._v(" "),_("p",[a._v("联合索引：索引可以覆盖多个数据链")]),a._v(" "),_("p",[a._v("全文索引：通过建立倒排索引，提升检索效率")]),a._v(" "),_("h3",{attrs:{id:"_7-聚簇索引和非聚簇索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-聚簇索引和非聚簇索引"}},[a._v("#")]),a._v(" 7.聚簇索引和非聚簇索引")]),a._v(" "),_("p",[a._v("都是b+树的数据结构")]),a._v(" "),_("p",[a._v("聚簇索引吧数据存储和索引放到了一块，按照一定的顺序组织的，数据的物理存放顺序与索引顺序是一致的。")]),a._v(" "),_("p",[a._v("非聚簇索引存储的是数据行地址，根据索引查询到地址，然后再去磁盘查询数据。")]),a._v(" "),_("h3",{attrs:{id:"_8-mysql索引结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-mysql索引结构"}},[a._v("#")]),a._v(" 8.mysql索引结构")]),a._v(" "),_("h3",{attrs:{id:"_9-having和where的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-having和where的区别"}},[a._v("#")]),a._v(" 9.having和where的区别")]),a._v(" "),_("p",[a._v("having是在分组后对数据进行过滤，和group by配合使用，having后面可使用聚合函数")]),a._v(" "),_("p",[a._v("where是在分组前对数据进行过滤，where后面不可以使用聚合")]),a._v(" "),_("h2",{attrs:{id:"并发编程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发编程"}},[a._v("#")]),a._v(" 并发编程")]),a._v(" "),_("h3",{attrs:{id:"进程与线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[a._v("#")]),a._v(" 进程与线程")]),a._v(" "),_("p",[a._v("进程是指运行中的程序，比如当我们使用应用时，就启动了一个进程，系统就会为该进程分配内存空间。线程由进程创建的，是进程的一个实体。一个进程可以拥有多个线程，一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。")]),a._v(" "),_("h3",{attrs:{id:"_1-线程的生命周期、线程的状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-线程的生命周期、线程的状态"}},[a._v("#")]),a._v(" 1.线程的生命周期、线程的状态")]),a._v(" "),_("p",[a._v("创建、就绪、运行、阻塞、死亡")]),a._v(" "),_("p",[a._v("阻塞分为三种：")]),a._v(" "),_("p",[a._v("等待阻塞，运行的线程执行wait方法，该线程会释放所有占用的资源，jvm把线程放入等待池中，不能自动唤醒，必须依靠其他线程调用notify或notifyall方法才能被唤醒。")]),a._v(" "),_("p",[a._v("同步阻塞：线程在获取对象的同步锁的时，如果同步锁被占用，jvm会吧该线程放入锁池中。")]),a._v(" "),_("p",[a._v("其他阻塞：线程执行sleep方法或join方法，或者发出io请求，jvm会吧线程设为阻塞状态。sleep超时、join等待线程终止或超时、io处理完毕，线程会重新进入就绪状态。")]),a._v(" "),_("p",[a._v("创建new——创建线程对象")]),a._v(" "),_("p",[a._v("就绪runable——线程创建后，其他线程调用了该对象的start方法，该状态的线程位于可运行线程池中")]),a._v(" "),_("p",[a._v("运行running——就绪状态的线程获取了cpu，执行程序代码")]),a._v(" "),_("p",[a._v("阻塞blocked——线程因某种原因放弃的cpu使用，暂停运行。知道线程进入就绪状态，才有机会转到运行状态。")]),a._v(" "),_("p",[a._v("死亡状态dead——线程执行完或者因为异常而退出run方法，线程生命周期结束")]),a._v(" "),_("h3",{attrs:{id:"_2-sleep、wait、yield、join、"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-sleep、wait、yield、join、"}},[a._v("#")]),a._v(" 2.sleep、wait、yield、join、")]),a._v(" "),_("p",[a._v("锁池：需要拿到同步锁的线程都会放在锁池中。当某个线程拿到锁后，其他线程在锁池中等待，当线程释放锁之后去竞争锁，拿到锁后进入就绪队列等待cpu分配资源。")]),a._v(" "),_("p",[a._v("等待池：调用wait方法后，线程会放到等待池中，并释放锁，只有调用了notify或notifyall后等待池的线程才会开始竞争锁。notify是随机从等待池中选一个线程放到锁池，notifyall是将所有线程放到锁池。")]),a._v(" "),_("p",[a._v("sleep是thread类的静态方法，wait是object类中的方法")]),a._v(" "),_("p",[a._v("sleep方法不会释放锁，而wait会释放锁，将线程加入到等待队列中")]),a._v(" "),_("p",[a._v("sleep方法不依赖synchronized，wait需要")]),a._v(" "),_("p",[a._v("sleep用于线程休眠，而wait多用于多线程之间的通信")]),a._v(" "),_("p",[a._v("都可被inter rup ted 方法终端。")]),a._v(" "),_("p",[a._v("yield执行后线程直接进入就绪状态，释放cpu的执行，但保留cpu的执行资格")]),a._v(" "),_("p",[a._v("join线程的插队。插队的线程一旦插队成功，原本的线程会进入阻塞状态，先执行完插入的线程所有的任务。")]),a._v(" "),_("h3",{attrs:{id:"_3-对线程安全的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-对线程安全的理解"}},[a._v("#")]),a._v(" 3.对线程安全的理解")]),a._v(" "),_("p",[a._v("线程安全其实就是数据的安全，保证多个线程执行对象时，最终的执行的结果都是正确的。")]),a._v(" "),_("h3",{attrs:{id:"_4-thread与runable"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-thread与runable"}},[a._v("#")]),a._v(" 4.Thread与Runable")]),a._v(" "),_("p",[a._v("通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，Thread类本身就实现了Runnable接口。")]),a._v(" "),_("h3",{attrs:{id:"_5-线程守护的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-线程守护的理解"}},[a._v("#")]),a._v(" 5.线程守护的理解")]),a._v(" "),_("p",[a._v("为所有非守护线程提供服务的线程，当所有的用户线程结束，守护线程自动结束")]),a._v(" "),_("p",[a._v("（setDae mon(true)）")]),a._v(" "),_("p",[a._v("常见的守护线程：垃圾回收机制")]),a._v(" "),_("h3",{attrs:{id:"_6-threadlocal的原理与使用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-threadlocal的原理与使用场景"}},[a._v("#")]),a._v(" 6.threadlocal的原理与使用场景")]),a._v(" "),_("h3",{attrs:{id:"_7-threadlocal内存泄漏"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-threadlocal内存泄漏"}},[a._v("#")]),a._v(" 7.threadlocal内存泄漏")]),a._v(" "),_("h3",{attrs:{id:"_8-并发、并行、串行的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-并发、并行、串行的区别"}},[a._v("#")]),a._v(" 8.并发、并行、串行的区别")]),a._v(" "),_("p",[a._v("串行在时间上不会重叠")]),a._v(" "),_("p",[a._v("并行在时间上是重叠的，两个任务在同一时刻执行，互不干扰")]),a._v(" "),_("p",[a._v("并发允许两个任务彼此干扰，同一时间点只有一个任务运行，交替执行")]),a._v(" "),_("h3",{attrs:{id:"_9-并发的三大特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-并发的三大特性"}},[a._v("#")]),a._v(" 9.并发的三大特性")]),a._v(" "),_("h3",{attrs:{id:"_10-线程池、线程池参数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-线程池、线程池参数"}},[a._v("#")]),a._v(" 10.线程池、线程池参数")])])}),[],!1,null,null,null);t.default=r.exports}}]);